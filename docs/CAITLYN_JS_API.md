# Caitlyn JavaScript API Reference

**Emscripten-Generated WASM Interface Documentation**

This document describes the official Caitlyn JavaScript interface as generated by Emscripten from the C++ codebase (`docs/cxx/caitlyn_js.cpp`). The interface provides direct access to Caitlyn's native C++ classes and functions through WebAssembly, enabling high-performance financial data processing in JavaScript environments.

## Architecture Overview

```
JavaScript Application
     ‚îÇ
     ‚îÇ ‚îÄ‚îÄ Direct API Calls ‚îÄ‚îÄ‚Üí WASM Module (caitlyn_js.wasm)
     ‚îÇ                              ‚îÇ
     ‚îÇ                         C++ Classes
     ‚îÇ                      (NetPackage, IndexSchema, 
     ‚îÇ                       ATUniverseReq, etc.)
     ‚îÇ                              ‚îÇ
     ‚îÇ ‚Üê‚îÄ‚îÄ Native Responses ‚îÄ‚îÄ‚îÄ‚îÄ Binary Protocol ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Caitlyn Server
```

**Key Points:**
- **Emscripten Bindings**: Direct C++ class exposure to JavaScript via Emscripten
- **Native Performance**: Zero-copy operations and native C++ processing speed
- **Type Safety**: Strongly typed API with proper error handling
- **Memory Management**: Emscripten's smart pointer integration with manual cleanup

## Command Constants

**Generated from C++ Emscripten Bindings**

All command constants are directly exported from the C++ codebase as integer constants:

### Network Layer Commands
```javascript
// Connection and protocol management
wasmModule.NET_CMD_GOLD_ROUTE_KEEPALIVE     // Keepalive messages
wasmModule.NET_CMD_GOLD_ROUTE_DATADEF       // Schema definition messages
```

### Core Protocol Commands
```javascript
// Universe and metadata operations
wasmModule.CMD_AT_UNIVERSE_REV               // Universe revision requests/responses
wasmModule.CMD_AT_UNIVERSE_META              // Universe metadata
wasmModule.CMD_AT_UNIVERSE_SEEDS             // Universe seeds (market data)

// Data fetching operations
wasmModule.CMD_AT_FETCH_BY_CODE              // Fetch data by security code
wasmModule.CMD_AT_FETCH_BY_TIME              // Fetch data by time
wasmModule.CMD_AT_FETCH_BY_TIME_RANGE        // Fetch data by time range

// Formula and calculation
wasmModule.CMD_AT_RUN_FORMULA                // Run formula
wasmModule.CMD_AT_REG_FORMULA                // Register formula
wasmModule.CMD_AT_DEL_FORMULA                // Delete formula
wasmModule.CMD_AT_CAL_FORMULA                // Calculate formula
wasmModule.CMD_AT_REG_LIBRARIES              // Register libraries

// Subscription operations
wasmModule.CMD_AT_SUBSCRIBE                  // Subscribe to data feeds
wasmModule.CMD_AT_SUBSCRIBE_SORT             // Subscribe with sorting
wasmModule.CMD_AT_UNSUBSCRIBE                // Unsubscribe from feeds
```

### Trading and Account Management
```javascript
// Account operations
wasmModule.CMD_AT_ACCOUNT_ADD                // Add trading accounts
wasmModule.CMD_AT_ACCOUNT_DEL                // Delete trading accounts  
wasmModule.CMD_AT_ACCOUNT_EDIT               // Edit trading accounts
wasmModule.CMD_AT_ACCOUNT_CHANGE_CAPITAL     // Change account capital

// Trading operations
wasmModule.CMD_AT_MANUAL_TRADE               // Manual trading operations
wasmModule.CMD_AT_MANUAL_EDIT                // Edit manual trades
wasmModule.CMD_AT_MODIFY_BASKET              // Modify basket
wasmModule.CMD_AT_QUERY_ORDERS               // Query orders

// Risk management
wasmModule.CMD_AT_ADD_LIMITS                 // Add limits
wasmModule.CMD_AT_DEL_LIMITS                 // Delete limits
wasmModule.CMD_AT_SKIP_BREACH                // Skip breach
```

### Strategy Management
```javascript
wasmModule.CMD_AT_ADD_STRATEGY_INSTANCE      // Add strategy instance
wasmModule.CMD_AT_DEL_STRATEGY_INSTANCE      // Delete strategy instance
wasmModule.CMD_AT_EDIT_STRATEGY_INSTANCE     // Edit strategy instance
wasmModule.CMD_AT_QUERY_STRATEGY_INSTANCE    // Query strategy instance
wasmModule.CMD_AT_QUERY_STRATEGY_INSTANCE_LOG // Query strategy instance log
```

### Backtesting Operations
```javascript
wasmModule.CMD_AT_START_BACKTEST             // Start backtest
wasmModule.CMD_AT_CTRL_BACKTEST              // Control backtest execution
wasmModule.CMD_AT_SHARE_BACKTEST             // Share backtest
wasmModule.CMD_AT_QUERY_BACK_TEST_PROCS      // Query backtest processes
wasmModule.CMD_AT_QUERY_BACK_TEST_PROC_LOG   // Query backtest process log
wasmModule.CMD_AT_QUERY_BACK_TEST_PROC_CONTROL // Query backtest process control
```

### Market Data Push Operations
```javascript
wasmModule.CMD_TA_MARKET_STATUS              // Market status updates
wasmModule.CMD_TA_PUSH_DATA                  // Real-time market data push
wasmModule.CMD_TA_SUBSCRIBE_HEADER           // Subscribe header
wasmModule.CMD_TA_PUSH_PROGRESS              // Progress notifications
wasmModule.CMD_TA_PUSH_LOG                   // Log messages
wasmModule.CMD_TA_MARKET_SINGULARITY         // Market singularity events
wasmModule.CMD_TA_PUSH_FORMULA               // Formula push
```

### Debug and System Commands
```javascript
wasmModule.CMD_AT_DEBUG_LIVE                 // Debug live
wasmModule.CMD_AT_DEBUG_COVERUP              // Debug coverup
wasmModule.CMD_AT_DEBUG_ADD_ACCOUNT          // Debug add account
wasmModule.CMD_AT_HANDSHAKE                  // Handshake
```

### Namespace Constants
```javascript
wasmModule.NAMESPACE_GLOBAL                  // Global namespace (0)
wasmModule.NAMESPACE_PRIVATE                 // Private namespace (1)
```

## Core Classes

**Emscripten-Bound C++ Classes**

All classes are directly bound from C++ using Emscripten's `class_<>` bindings.

### NetPackage - Binary Message Container
```javascript
// C++ class: _net_package
const pkg = new wasmModule.NetPackage();

// Properties (direct C++ member access):
pkg.header.cmd                               // Command from NetHeader (int16_t)

// Methods (bound C++ functions):
pkg.encode(cmd, content)                     // Returns typed_memory_view<uint8_t>
pkg.decode(data)                            // Decodes binary string data
pkg.content()                               // Returns typed_memory_view of content
pkg.length()                                // Returns content size (size_t)
pkg.delete()                                // Emscripten destructor - REQUIRED

// Usage Example:
const req = new wasmModule.ATUniverseReq(token, sequenceId);
const pkg = new wasmModule.NetPackage();
const encodedReq = req.encode();
const encodedPkg = pkg.encode(wasmModule.CMD_AT_UNIVERSE_REV, encodedReq);

// encodedPkg is a typed_memory_view that can be sent directly
websocket.send(encodedPkg);

req.delete();
pkg.delete();
```

### StructValue - Dynamic Data Container
```javascript
// C++ class: _sv (bound as smart_ptr)
const sv = new wasmModule.StructValue();

// Properties (C++ getters/setters):
sv.namespace                                 // uint32_t namespace ID
sv.metaID                                   // uint32_t metadata ID
sv.timeTag                                  // uint64_t timestamp
sv.granularity                              // uint32_t granularity
sv.market                                   // std::string market code
sv.stockCode                                // std::string stock code
sv.fieldCount                               // size_t field count

// Type-specific field accessors:
sv.getInt32(fieldIndex)                     // Get int32_t field
sv.setInt32(fieldIndex, value)              // Set int32_t field
sv.getInt64(fieldIndex)                     // Get int64_t field
sv.setInt64(fieldIndex, value)              // Set int64_t field
sv.getDouble(fieldIndex)                    // Get double field
sv.setDouble(fieldIndex, value)             // Set double field
sv.getString(fieldIndex)                    // Get string field
sv.setString(fieldIndex, value)             // Set string field

// Vector field accessors:
sv.getInt32Vector(fieldIndex)               // Get std::vector<int32_t>
sv.setInt32Vector(fieldIndex, vector)      // Set std::vector<int32_t>
sv.getInt64Vector(fieldIndex)               // Get std::vector<int64_t>
sv.setInt64Vector(fieldIndex, vector)      // Set std::vector<int64_t>
sv.getDoubleVector(fieldIndex)              // Get std::vector<double>
sv.setDoubleVector(fieldIndex, vector)     // Set std::vector<double>
sv.getStringVector(fieldIndex)              // Get std::vector<std::string>
sv.setStringVector(fieldIndex, vector)     // Set std::vector<std::string>

// Utility methods:
sv.isEmpty(fieldIndex)                      // Check if field is empty
sv.reset()                                  // Reset all fields
sv.delete()                                 // Smart pointer cleanup
```

### IndexSchema - Schema Definition Container
```javascript
// C++ class: _index_schema (smart_ptr constructor)
const schema = new wasmModule.IndexSchema();

// Methods:
schema.load(binaryContent)                  // Load from compressed binary
schema.load_old_version(binaryContent)      // Load old version format
schema.metas()                              // Returns IndexMetaVector

// Usage:
const metas = schema.metas();
for (let i = 0; i < metas.size(); i++) {
    const meta = metas.get(i);
    console.log(`Namespace: ${meta.namespace}`);
    console.log(`ID: ${meta.ID}`);
    console.log(`Name: ${meta.name}`);
    console.log(`Display Name: ${meta.displayName}`);
    console.log(`Fields: ${meta.fields.size()}`);
}

schema.delete(); // Smart pointer cleanup
```

### IndexMeta - Metadata Definition
```javascript
// C++ class: _index_meta (accessed via IndexSchema)
// Properties (read-only C++ members):
meta.ID                                     // uint32_t metadata ID
meta.namespace                              // uint32_t namespace
meta.name                                   // std::string qualified name
meta.displayName                            // std::string display name
meta.granularities                          // std::vector<uint32_t>
meta.share                                  // ShareOption object
meta.indexType                              // uint32_t type
meta.revision                               // uint32_t revision
meta.authorUUID                             // std::string author UUID
meta.fields                                 // IndexFieldVector field definitions
```

### IndexField - Field Definition
```javascript
// C++ class: _index_field (accessed via IndexMeta.fields)
field.pos                                   // uint32_t field position
field.name                                  // std::string field name
field.type                                  // DataType enum value
field.precision                             // uint32_t precision
field.multiple                              // bool multiple flag
field.sampleType                            // uint32_t sample type
```

### IndexSerializer - Data Compression Engine
```javascript
// C++ class: _index_serializer (smart_ptr constructor)  
const compressor = new wasmModule.IndexSerializer();

// Methods:
compressor.updateSchema(schema)             // Update with IndexSchema
compressor.deserializeByTime(data)         // Deserialize time-series data

compressor.delete(); // Smart pointer cleanup
```

## Request Classes

**C++ Request Class Bindings**

All request classes inherit from `ATBaseRequest` and are bound as smart pointers.

### ATBaseRequest - Base Request Class
```javascript
// C++ class: _base_request (base class for all requests)
// Constructor:
new wasmModule.ATBaseRequest(token, sequenceId);

// Properties:
req.seq                                     // int32_t sequence ID
req.token                                   // std::string authentication token
```

### ATUniverseReq - Universe Revision Request
```javascript
// C++ class: _at_universe_req (inherits ATBaseRequest)
const req = new wasmModule.ATUniverseReq(token, sequenceId);

// Inherited properties:
req.seq                                     // int32_t sequence ID  
req.token                                   // std::string token

// Methods:
req.encode()                                // Returns encoded binary string
req.delete()                                // Smart pointer cleanup
```

### ATUniverseSeedsReq - Universe Seeds Request
```javascript
// C++ class: _at_universe_seeds_req (inherits ATBaseRequest)
const req = new wasmModule.ATUniverseSeedsReq(
    token,          // std::string authentication token
    sequenceId,     // int32_t sequence number
    revision,       // uint32_t data revision
    namespace,      // std::string namespace ("global" or "private")
    qualifiedName,  // std::string qualified name (e.g., "Market", "Commodity")
    market,         // std::string market code (e.g., "SHFE", "DCE")
    tradeDay        // int32_t trading day (YYYYMMDD format)
);

// Properties (C++ member access):
req.revision_                               // uint32_t revision
req.namespace_                              // std::string namespace
req.qualified_name_                         // std::string qualified name
req.market_                                 // std::string market
req.trade_day_                              // int32_t trade day

// Methods:
req.encode()                                // Returns encoded binary string
req.delete()                                // Smart pointer cleanup
```

### ATFetchByCodeReq - Fetch Data by Security Code
```javascript
// C++ class: _at_fetch_by_code_req (inherits ATBaseRequest)
const req = new wasmModule.ATFetchByCodeReq(
    token,          // std::string authentication token
    sequenceId,     // int32_t sequence number
    namespace,      // std::string namespace
    qualifiedName,  // std::string qualified name
    revision,       // uint32_t revision
    market,         // std::string market code
    code,           // std::string security code
    fromTimeTag,    // uint64_t start time (Unix timestamp)
    toTimeTag,      // uint64_t end time (Unix timestamp)
    granularity,    // uint32_t granularity (seconds)
    fields          // std::vector<std::string> field names
);

// Properties (mapped property names):
req.namespace                               // std::string namespace
req.qualifiedName                           // std::string qualified name  
req.revision                                // uint32_t revision
req.market                                  // std::string market
req.code                                    // std::string code
req.fromTimeTag                             // uint64_t from time
req.toTimeTag                               // uint64_t to time
req.granularity                             // uint32_t granularity
req.fields                                  // std::vector<std::string> fields

// Methods:
req.encode()                                // Returns encoded binary string
req.delete()                                // Smart pointer cleanup
```

### ATFetchByTimeReq - Fetch Data by Time
```javascript
// C++ class: _at_fetch_by_time_req (inherits ATBaseRequest)
const req = new wasmModule.ATFetchByTimeReq(
    token,          // std::string authentication token
    sequenceId,     // int32_t sequence number
    namespace,      // std::string namespace  
    qualifiedName,  // std::string qualified name
    revision,       // uint32_t revision
    markets,        // std::vector<std::string> market codes
    codes,          // std::vector<std::string> security codes
    timeTag,        // uint64_t time tag
    granularity,    // uint32_t granularity
    fields          // std::vector<std::string> field names
);

// Properties (mapped property names):
req.namespace                               // std::string namespace
req.qualifiedName                           // std::string qualified name
req.revisions                               // uint32_t revision (note: mapped name)
req.markets                                 // std::vector<std::string> markets
req.codes                                   // std::vector<std::string> codes
req.timeTag                                 // uint64_t time tag
req.granularity                             // uint32_t granularity
req.fields                                  // std::vector<std::string> fields

// Methods:
req.encode()                                // Returns encoded binary string
req.delete()                                // Smart pointer cleanup
```

### ATFetchByTimeRangeReq - Fetch Data by Time Range
```javascript
// C++ class: _at_fetch_by_time_range_req (inherits ATBaseRequest)
const req = new wasmModule.ATFetchByTimeRangeReq();

// Properties:
req.namespace                               // std::string namespace
req.qualifiedName                           // std::string qualified name
req.revision                                // uint32_t revision
req.markets                                 // std::vector<std::string> markets
req.codes                                   // std::vector<std::string> codes
req.fromTimeTag                             // uint64_t from time
req.toTimeTag                               // uint64_t to time
req.granularity                             // uint32_t granularity
req.fields                                  // std::vector<std::string> fields

// Methods:
req.encode()                                // Returns encoded binary string
req.delete()                                // Smart pointer cleanup
```

## Response Classes

**C++ Response Class Bindings**

All response classes inherit from `ATBaseResponse` and are bound as smart pointers.

### ATBaseResponse - Base Response Class
```javascript
// C++ class: _base_response (base class for all responses)
// Constructors:
new wasmModule.ATBaseResponse();             // Default constructor
new wasmModule.ATBaseResponse(sequenceId);   // With sequence ID

// Properties:
res.seq                                     // int32_t sequence ID
res.status                                  // Response status
res.errorCode                               // Error code (ErrorCode enum)
res.errorMsg                                // std::string error message

// Methods:
res.decode(binaryContent)                   // Decode from binary string
```

### ATUniverseRes - Universe Revision Response
```javascript
// C++ class: _at_universe_res (inherits ATBaseResponse, smart_ptr)
const res = new wasmModule.ATUniverseRes();
// or with sequence ID:
const res = new wasmModule.ATUniverseRes(sequenceId);

// Required setup:
res.setCompressor(compressor)               // MUST set IndexSerializer before decode
res.decode(binaryContent)                   // Decode compressed response

// Methods:
res.revs()                                  // Returns RevisionMap (map<string, StructValueConstVector>)

// Processing revisions:
const revs = res.revs();                    // Map from namespace to StructValue vectors
const keys = revs.keys();                   // Keys: "global", "private"

for (let i = 0; i < keys.size(); i++) {
    const namespaceKey = keys.get(i);       // "global" or "private"
    const structValues = revs.get(namespaceKey); // StructValueConstVector
    
    for (let j = 0; j < structValues.size(); j++) {
        const sv = structValues.get(j);     // Individual StructValue
        // Process market data from sv.metaID, sv.getString(7), etc.
        sv.delete();                        // Clean up individual StructValue
    }
}

res.delete(); // Smart pointer cleanup
```

### ATUniverseSeedsRes - Universe Seeds Response
```javascript
// C++ class: _at_universe_seeds_res (inherits ATBaseResponse)
const res = new wasmModule.ATUniverseSeedsRes();
// or with parameters:
const res = new wasmModule.ATUniverseSeedsRes(sequenceId, token);

// Required setup:
res.setCompressor(compressor)               // MUST set IndexSerializer before decode
res.decode(binaryContent)                   // Decode compressed response

// Methods:
res.seedData()                              // Returns StructValueConstVector

// Processing seed data:
const seedData = res.seedData();            // Vector of StructValue objects
for (let i = 0; i < seedData.size(); i++) {
    const sv = seedData.get(i);             // Individual StructValue
    
    // Access StructValue properties:
    console.log(`MetaID: ${sv.metaID}`);
    console.log(`Market: ${sv.market}`);
    console.log(`StockCode: ${sv.stockCode}`);
    
    // Process based on the specific data type
    // Use schema to determine correct field access patterns
    
    sv.delete();                            // Clean up individual StructValue
}

res.delete(); // Smart pointer cleanup
```

### ATFetchSVRes - Fetch StructValue Response
```javascript
// C++ class: _at_fetch_sv_res (inherits ATBaseResponse, smart_ptr)
const res = new wasmModule.ATFetchSVRes();
// or with parameters:
const res = new wasmModule.ATFetchSVRes(sequenceId, fields, namespace);

// Required setup:
res.setCompressor(compressor)               // MUST set IndexSerializer before decode
res.decode(binaryContent)                   // Decode compressed response

// Properties:
res.fields                                  // std::vector<std::string> field names
res.namespace                               // std::string namespace

// Methods:
res.results()                               // Returns StructValueConstVector
res.json_results()                          // Returns JSON representation

// Processing results:
const results = res.results();              // Vector of StructValue objects
for (let i = 0; i < results.size(); i++) {
    const sv = results.get(i);              // Individual StructValue
    
    // Process the fetched data
    // Field access depends on the specific qualified name and schema
    
    sv.delete();                            // Clean up individual StructValue
}

res.delete(); // Smart pointer cleanup
```

## Enums and Data Types

**Emscripten-Bound C++ Enums**

### ErrorCode Enum
```javascript
// C++ enum: ERROR_CODE (comprehensive error codes)
wasmModule.ErrorCode.CAITLYN_ERROR_SUCCESS           // Success
wasmModule.ErrorCode.ERROR_FORMAT                    // Format error
wasmModule.ErrorCode.ERROR_NO_CMD                    // No command
wasmModule.ErrorCode.ERROR_NO_FIELD                  // No field
wasmModule.ErrorCode.ERROR_EXIST_ACCOUNT             // Account exists
wasmModule.ErrorCode.ERROR_NETWORK                   // Network error
wasmModule.ErrorCode.ERROR_TOKEN                     // Token error
wasmModule.ErrorCode.ERROR_MARKET                    // Market error
wasmModule.ErrorCode.ERROR_NAMESPACE                 // Namespace error
wasmModule.ErrorCode.ERROR_QUALIFIED_NAME            // Qualified name error
wasmModule.ErrorCode.CAITLYN_ERROR_INVALID_PARAMETER // Invalid parameter
wasmModule.ErrorCode.CAITLYN_ERROR_NO_TOKEN          // No token
wasmModule.ErrorCode.ERROR_EXPIRE_TOKEN              // Expired token
wasmModule.ErrorCode.ERROR_UNKNOWN                   // Unknown error
// ... and many more
```

### DataType Enum
```javascript
// C++ enum: _data_type (field data types)
wasmModule.DataType.INT                     // int32_t
wasmModule.DataType.DOUBLE                  // double
wasmModule.DataType.STRING                  // std::string
wasmModule.DataType.VINT                    // std::vector<int32_t>
wasmModule.DataType.VDOUBLE                 // std::vector<double>
wasmModule.DataType.VSTRING                 // std::vector<std::string>
wasmModule.DataType.INT64                   // int64_t
wasmModule.DataType.VINT64                  // std::vector<int64_t>
```

### ClientCategory Enum
```javascript
// C++ enum: _client_category (client types)
wasmModule.ClientCategory.None              // No category
wasmModule.ClientCategory.IndexCalculator   // Index calculator
wasmModule.ClientCategory.StrategyCalculator // Strategy calculator
wasmModule.ClientCategory.Einstein          // Einstein client
wasmModule.ClientCategory.Dirac             // Dirac client
wasmModule.ClientCategory.Bohr              // Bohr client
wasmModule.ClientCategory.Custom            // Custom client
```

### RuntimeType Enum
```javascript
// C++ enum: _runtime_type (runtime modes)
wasmModule.RuntimeType.Test                 // Backtest mode
wasmModule.RuntimeType.Live                 // Live trading mode
```

## Utility Functions

**Global Functions Exported from C++**

### Version Information
```javascript
// Get WASM module version
const version = wasmModule.version();       // Returns: 2022012301 (uint32_t)
console.log(`Caitlyn WASM Version: ${version}`);

// Mathematical constants (example function)
const pi = wasmModule.mypi();              // Returns: 3.1415926535
```

## Vector Types

**Emscripten-Registered C++ Vectors**

The C++ bindings register various vector types for JavaScript access:

```javascript
// Numeric vectors
new wasmModule.Int32Vector()                // std::vector<int32_t>
new wasmModule.Int64Vector()                // std::vector<int64_t>
new wasmModule.Uint32Vector()               // std::vector<uint32_t>
new wasmModule.Uint64Vector()               // std::vector<uint64_t>
new wasmModule.DoubleVector()               // std::vector<double>

// String vectors  
new wasmModule.StringVector()               // std::vector<std::string>
new wasmModule.StringMatrix()               // std::vector<std::vector<std::string>>

// Complex vectors
new wasmModule.IndexFieldVector()           // std::vector<_index_field>
new wasmModule.IndexMetaVector()            // std::vector<_index_meta>
new wasmModule.StructValueConstVector()     // std::vector<_sv_ptr>

// Map types
new wasmModule.RevisionMap()                // std::map<std::string, _sv_const_ptr_array>

// Vector methods (all vectors have these):
vector.size()                               // Get vector size
vector.get(index)                           // Get element at index
vector.set(index, value)                    // Set element at index  
vector.push_back(value)                     // Add element to end
vector.delete()                             // Clean up vector
```

## Common Usage Patterns

**Production-Ready Emscripten Integration Examples**

### 1. WASM Module Loading and Verification

```javascript
// 1. Load WASM module with proper error handling
async function loadCaitlynWasm(wasmPath) {
    try {
        const wasmModule = await import(wasmPath);
        
        // Verify critical classes are available
        const requiredClasses = [
            'NetPackage', 'IndexSchema', 'IndexSerializer',
            'StructValue', 'ATUniverseReq', 'ATUniverseRes',
            'ATUniverseSeedsReq', 'ATUniverseSeedsRes'
        ];
        
        for (const className of requiredClasses) {
            if (typeof wasmModule[className] === 'undefined') {
                throw new Error(`Required class ${className} not found in WASM module`);
            }
        }
        
        // Verify constants
        const requiredConstants = [
            'NET_CMD_GOLD_ROUTE_DATADEF', 'CMD_AT_UNIVERSE_REV',
            'CMD_AT_UNIVERSE_SEEDS', 'NAMESPACE_GLOBAL'
        ];
        
        for (const constant of requiredConstants) {
            if (typeof wasmModule[constant] === 'undefined') {
                throw new Error(`Required constant ${constant} not found`);
            }
        }
        
        console.log(`‚úÖ Caitlyn WASM loaded successfully, version: ${wasmModule.version()}`);
        return wasmModule;
        
    } catch (error) {
        console.error('‚ùå Failed to load Caitlyn WASM:', error);
        throw error;
    }
}
```

### 2. Binary Message Processing with NetPackage

```javascript
// Handle incoming binary WebSocket messages
function handleBinaryMessage(arrayBuffer, wasmModule) {
    const pkg = new wasmModule.NetPackage();
    
    try {
        // Convert ArrayBuffer to string for NetPackage.decode
        const uint8Array = new Uint8Array(arrayBuffer);
        const binaryString = String.fromCharCode.apply(null, uint8Array);
        
        pkg.decode(binaryString);
        const cmd = pkg.header.cmd;
        const content = pkg.content(); // typed_memory_view
        
        console.log(`üì® Received command: ${cmd} (${getCommandName(cmd, wasmModule)})`);
        
        // Route based on command
        switch (cmd) {
            case wasmModule.NET_CMD_GOLD_ROUTE_KEEPALIVE:
                // Keepalive - no action needed
                break;
                
            case wasmModule.NET_CMD_GOLD_ROUTE_DATADEF:
                handleSchemaDefinition(content, wasmModule);
                break;
                
            case wasmModule.CMD_AT_UNIVERSE_REV:
                handleUniverseRevision(content, wasmModule);
                break;
                
            case wasmModule.CMD_AT_UNIVERSE_SEEDS:
                handleUniverseSeeds(content, wasmModule);
                break;
                
            default:
                console.warn(`Unhandled command: ${cmd}`);
        }
        
    } catch (error) {
        console.error('Error processing binary message:', error);
    } finally {
        pkg.delete(); // Always cleanup NetPackage
    }
}

// Helper function to get command name for debugging
function getCommandName(cmd, wasmModule) {
    const commandMap = {
        [wasmModule.NET_CMD_GOLD_ROUTE_KEEPALIVE]: 'KEEPALIVE',
        [wasmModule.NET_CMD_GOLD_ROUTE_DATADEF]: 'DATADEF',
        [wasmModule.CMD_AT_UNIVERSE_REV]: 'UNIVERSE_REV',
        [wasmModule.CMD_AT_UNIVERSE_SEEDS]: 'UNIVERSE_SEEDS',
        [wasmModule.CMD_AT_FETCH_BY_CODE]: 'FETCH_BY_CODE'
    };
    return commandMap[cmd] || 'UNKNOWN';
}
```

### 3. Schema Processing and Compressor Initialization

```javascript
// Handle schema definition message
function handleSchemaDefinition(content, wasmModule) {
    const schema = new wasmModule.IndexSchema();
    const compressor = new wasmModule.IndexSerializer();
    
    try {
        // Load schema from binary content
        schema.load(content);
        
        // Build schema lookup for metadata access
        const schemaLookup = buildSchemaLookup(schema);
        
        // Initialize compressor with schema
        compressor.updateSchema(schema);
        
        console.log(`üìã Schema loaded: ${schemaLookup.totalMetas} metadata definitions`);
        console.log(`    Global namespace: ${schemaLookup.globalMetas.length} metas`);
        console.log(`    Private namespace: ${schemaLookup.privateMetas.length} metas`);
        
        // Store globally for other operations
        window.caitlynSchema = schemaLookup;
        window.caitlynCompressor = compressor;
        
        // Request universe revision data
        requestUniverseRevision(wasmModule);
        
    } catch (error) {
        console.error('‚ùå Schema processing failed:', error);
        compressor.delete();
    } finally {
        schema.delete(); // Delete schema after transferring to compressor
    }
}

// Build searchable schema lookup
function buildSchemaLookup(schema) {
    const metas = schema.metas();
    const lookup = {
        byNamespace: { 0: {}, 1: {} }, // namespace -> metaID -> meta
        byName: {},                    // qualified name -> meta
        globalMetas: [],
        privateMetas: [],
        totalMetas: metas.size()
    };
    
    for (let i = 0; i < metas.size(); i++) {
        const meta = metas.get(i);
        
        // Store by namespace and ID
        lookup.byNamespace[meta.namespace][meta.ID] = meta;
        
        // Store by qualified name
        lookup.byName[meta.name] = meta;
        
        // Categorize by namespace
        if (meta.namespace === 0) {
            lookup.globalMetas.push(meta);
        } else {
            lookup.privateMetas.push(meta);
        }
        
        console.log(`  üìÑ Meta: ${meta.name} (ID: ${meta.ID}, Fields: ${meta.fields.size()})`);
    }
    
    return lookup;
}
```

### 4. Universe Revision Processing

```javascript
// Process universe revision response
function handleUniverseRevision(content, wasmModule) {
    const res = new wasmModule.ATUniverseRes();
    
    try {
        // Set compressor and decode
        res.setCompressor(window.caitlynCompressor);
        res.decode(content);
        
        // Process revision map
        const revs = res.revs();
        const keys = revs.keys();
        
        console.log(`üåç Processing universe revision for ${keys.size()} namespaces`);
        
        const marketsData = {};
        
        for (let i = 0; i < keys.size(); i++) {
            const namespaceKey = keys.get(i); // "global" or "private"
            const structValues = revs.get(namespaceKey);
            
            console.log(`  üìä ${namespaceKey} namespace: ${structValues.size()} entries`);
            
            for (let j = 0; j < structValues.size(); j++) {
                const sv = structValues.get(j);
                
                try {
                    // Look for Market metadata (use schema to find correct ID)
                    const marketMeta = window.caitlynSchema.byName[`${namespaceKey}::Market`];
                    
                    if (marketMeta && sv.metaID === marketMeta.ID) {
                        const marketData = processMarketStructValue(sv, namespaceKey);
                        if (marketData) {
                            if (!marketsData[namespaceKey]) marketsData[namespaceKey] = {};
                            marketsData[namespaceKey][marketData.code] = marketData;
                        }
                    }
                    
                } finally {
                    sv.delete(); // Always cleanup StructValue
                }
            }
        }
        
        // Store processed market data
        window.caitlynMarkets = marketsData;
        
        // Request universe seeds for all markets
        requestUniverseSeeds(marketsData, wasmModule);
        
    } catch (error) {
        console.error('‚ùå Universe revision processing failed:', error);
    } finally {
        res.delete(); // Always cleanup response
    }
}

// Process individual market StructValue
function processMarketStructValue(sv, namespace) {
    try {
        // Use schema-based field access (discovered patterns)
        const tradeDay = sv.isEmpty(0) ? 0 : sv.getInt32(0);        // Field 0: trade_day
        const displayName = sv.getString(1);                         // Field 1: name
        const timeZone = sv.isEmpty(2) ? '' : sv.getString(2);      // Field 2: time_zone
        const revisionsJson = sv.isEmpty(7) ? '{}' : sv.getString(7); // Field 7: revisions JSON
        
        const revisions = JSON.parse(revisionsJson);
        
        return {
            code: sv.stockCode,           // Market code (SHFE, DCE, etc.)
            name: displayName,            // Display name
            namespace: namespace,
            tradeDay: tradeDay,
            timeZone: timeZone,
            revisions: revisions          // Qualified name -> revision number
        };
        
    } catch (error) {
        console.error('‚ùå Failed to process market StructValue:', error);
        return null;
    }
}
```

### 5. Memory Management Best Practices

```javascript
// Resource management with automatic cleanup
class CaitlynResourceManager {
    constructor(wasmModule) {
        this.wasmModule = wasmModule;
        this.managedObjects = new Set();
    }
    
    // Create and track WASM objects
    create(className, ...args) {
        const obj = new this.wasmModule[className](...args);
        this.managedObjects.add(obj);
        return obj;
    }
    
    // Manual cleanup of specific object
    cleanup(obj) {
        if (this.managedObjects.has(obj)) {
            obj.delete();
            this.managedObjects.delete(obj);
        }
    }
    
    // Cleanup all managed objects
    cleanupAll() {
        for (const obj of this.managedObjects) {
            try {
                obj.delete();
            } catch (error) {
                console.warn('Failed to delete WASM object:', error);
            }
        }
        this.managedObjects.clear();
    }
    
    // Get object count for monitoring
    getObjectCount() {
        return this.managedObjects.size;
    }
}

// Usage example:
function processDataSafely(wasmModule) {
    const resourceManager = new CaitlynResourceManager(wasmModule);
    
    try {
        // Create managed objects
        const pkg = resourceManager.create('NetPackage');
        const req = resourceManager.create('ATUniverseReq', token, sequenceId);
        const res = resourceManager.create('ATUniverseRes');
        
        // Use objects normally
        const encodedReq = req.encode();
        const encodedPkg = pkg.encode(wasmModule.CMD_AT_UNIVERSE_REV, encodedReq);
        
        // Process data...
        
        console.log(`üìä Currently managing ${resourceManager.getObjectCount()} WASM objects`);
        
    } catch (error) {
        console.error('Processing failed:', error);
    } finally {
        // Automatic cleanup of all objects
        resourceManager.cleanupAll();
        console.log('‚úÖ All WASM objects cleaned up');
    }
}
```

## Performance Considerations

**Emscripten-Specific Optimizations**

### 1. Memory Allocation Patterns
```javascript
// ‚úÖ Good: Reuse objects when processing multiple items
const pkg = new wasmModule.NetPackage();
const req = new wasmModule.ATUniverseReq(token, 1);

for (const item of items) {
    // Reuse same objects
    processItem(item, pkg, req);
}

pkg.delete();
req.delete();

// ‚ùå Bad: Create new objects in loop
for (const item of items) {
    const pkg = new wasmModule.NetPackage(); // Expensive allocation
    const req = new wasmModule.ATUniverseReq(token, 1);
    processItem(item, pkg, req);
    pkg.delete();
    req.delete();
}
```

### 2. Memory Monitoring
```javascript
// Monitor WASM heap usage
function getWasmMemoryInfo() {
    return {
        totalJSHeapSize: performance.memory?.totalJSHeapSize || 0,
        usedJSHeapSize: performance.memory?.usedJSHeapSize || 0,
        wasmMemoryPages: wasmModule.buffer ? wasmModule.buffer.byteLength / 65536 : 0
    };
}

// Call periodically to monitor memory usage
setInterval(() => {
    const memInfo = getWasmMemoryInfo();
    console.log('WASM Memory Usage:', memInfo);
}, 30000);
```

### 3. Typed Memory Views
```javascript
// NetPackage.encode() returns typed_memory_view - use directly
const pkg = new wasmModule.NetPackage();
const encodedData = pkg.encode(cmd, content);

// ‚úÖ Good: Use directly without copying
websocket.send(encodedData);

// ‚ùå Bad: Unnecessary copying (unless required for browser compatibility)
const regularArray = new Uint8Array(encodedData.length);
regularArray.set(encodedData);
websocket.send(regularArray);

pkg.delete();
```

## Error Handling and Debugging

**Production Error Handling Strategies**

### 1. WASM Exception Handling
```javascript
function safeWasmOperation(wasmModule) {
    let objects = [];
    
    try {
        const schema = new wasmModule.IndexSchema();
        objects.push(schema);
        
        // Emscripten objects throw C++ exceptions as JavaScript errors
        schema.load(binaryData);
        
        return schema;
        
    } catch (error) {
        // C++ exceptions become JavaScript Error objects
        if (error.name === 'ExitStatus') {
            console.error('WASM module exited unexpectedly:', error.status);
        } else if (error.message?.includes('RuntimeError')) {
            console.error('WASM runtime error:', error.message);
        } else {
            console.error('Unknown WASM error:', error);
        }
        
        throw error; // Re-throw for higher level handling
        
    } finally {
        // Always cleanup allocated objects
        objects.forEach(obj => {
            try {
                obj.delete();
            } catch (cleanupError) {
                console.warn('Cleanup error:', cleanupError);
            }
        });
    }
}
```

### 2. Class and Method Verification
```javascript
// Verify WASM module integrity
function validateWasmModule(wasmModule) {
    const validationErrors = [];
    
    // Check critical classes
    const requiredClasses = [
        'NetPackage', 'IndexSchema', 'IndexSerializer', 'StructValue',
        'ATUniverseReq', 'ATUniverseRes', 'ATUniverseSeedsReq', 'ATUniverseSeedsRes'
    ];
    
    for (const className of requiredClasses) {
        if (typeof wasmModule[className] !== 'function') {
            validationErrors.push(`Missing class: ${className}`);
        }
    }
    
    // Check critical constants
    const requiredConstants = [
        'NET_CMD_GOLD_ROUTE_DATADEF', 'CMD_AT_UNIVERSE_REV', 'CMD_AT_UNIVERSE_SEEDS',
        'NAMESPACE_GLOBAL', 'NAMESPACE_PRIVATE'
    ];
    
    for (const constant of requiredConstants) {
        if (typeof wasmModule[constant] === 'undefined') {
            validationErrors.push(`Missing constant: ${constant}`);
        }
    }
    
    // Check version
    if (typeof wasmModule.version !== 'function') {
        validationErrors.push('Missing version() function');
    } else {
        const version = wasmModule.version();
        console.log(`‚úÖ Caitlyn WASM version: ${version}`);
    }
    
    if (validationErrors.length > 0) {
        throw new Error(`WASM module validation failed: ${validationErrors.join(', ')}`);
    }
    
    return true;
}
```

## Integration Best Practices

### 1. Initialization Checklist
- ‚úÖ Load WASM module and verify all required classes/constants
- ‚úÖ Set up proper error handling for C++ exceptions  
- ‚úÖ Implement resource management for automatic cleanup
- ‚úÖ Create schema lookup after processing schema definition
- ‚úÖ Initialize compressor with schema before decoding responses

### 2. Production Deployment
- ‚úÖ Monitor WASM memory usage and implement cleanup policies
- ‚úÖ Handle WebSocket reconnection with proper state management
- ‚úÖ Implement request timeout and retry mechanisms
- ‚úÖ Log all command types and sequence IDs for debugging
- ‚úÖ Use typed_memory_view directly for optimal performance

### 3. Development and Testing
- ‚úÖ Test with various market data scenarios
- ‚úÖ Verify proper StructValue field access using schema
- ‚úÖ Test memory cleanup under high load
- ‚úÖ Validate error handling for malformed messages
- ‚úÖ Monitor for memory leaks using browser dev tools

---

## Summary

This **Caitlyn JavaScript API Reference** provides comprehensive documentation for the Emscripten-generated WebAssembly interface. The API offers direct access to native C++ performance while maintaining JavaScript ease of use.

**Key Benefits:**
- **Native Performance**: Direct C++ execution via WebAssembly
- **Type Safety**: Strong typing with proper error handling
- **Memory Control**: Explicit memory management with smart pointers
- **Complete API**: Full access to all Caitlyn protocol features
- **Production Ready**: Battle-tested integration patterns

**Remember:** Always call `delete()` on WASM objects, use schema-based field access for StructValues, and implement proper error handling for production deployments.

For implementation examples, see the `docs/` folder and refer to the proven patterns in `docs/test.js` for universe initialization workflows.